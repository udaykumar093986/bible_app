<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Read — Bible Reader</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{--bg:#f7f9fc;--accent:#0b66c2;--border:#e2e8f0}
body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);color:#222}
.header{padding:12px 16px;background:#fff;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
.header a{color:var(--accent);text-decoration:none;font-weight:700}
.container{max-width:900px;margin:18px auto;padding:0 16px}
.controls-top{display:flex;gap:8px;align-items:center;margin-bottom:12px}
.select{padding:8px;border-radius:8px;border:1px solid var(--border);background:#fff}
.btn{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
.ref{font-size:20px;font-weight:700;color:var(--accent);margin-bottom:12px}
.verse-block{background:#fff;padding:14px;border-radius:10px;border:1px solid var(--border);margin-bottom:10px}
.verse-num{font-weight:700;margin-bottom:8px}
.verse-primary{font-family:"Noto Serif",serif;font-size:18px;line-height:1.7}
.verse-parallel{margin-top:10px;padding-left:14px;border-left:3px solid var(--accent);font-family:"Noto Serif",serif;font-size:17px;color:#2a3c55}
.active-verse{background:#fff8d1;border-color:#ffd56b}
.note{color:#666;font-size:13px;margin-left:auto}
@media(max-width:600px){.controls-top{flex-direction:column;align-items:stretch}.note{margin-left:0}}
</style>
</head>
<body>
<div class="header">
  <a href="/">← Back</a>
  <div style="flex:1"></div>
  <div class="note">Swipe left/right to change chapter</div>
</div>

<div class="container">
  <div class="controls-top">
    <select id="primarySel" class="select"></select>
    <select id="parallelSel" class="select"></select>
    <button id="playBtn" class="btn">▶ Play</button>
    <button id="pauseBtn" class="btn">⏸ Pause</button>
    <button id="resumeBtn" class="btn">⏯ Resume</button>
    <button id="stopBtn" class="btn">⏹ Stop</button>
  </div>

  <div id="ref" class="ref"></div>
  <div id="verses"></div>
</div>

<script>
(async function(){
  const BASE = "https://cdn.jsdelivr.net/gh/udaykumar093986/bibles@main/";
  // available versions (mirror the index list)
  const FILES = [
    "AMP_bible.json","CSB_bible.json","ESV_bible.json","KJV_bible.json","NIV_bible.json",
    "NKJV_bible.json","NLT_bible.json","afrikaans_bible.json","bengali_bible.json","gujarati_bible.json",
    "hindi_bible.json","hungarian_bible.json","indonesian_bible.json","kannada_bible.json","malayalam_bible.json",
    "marathi_bible.json","nepali_bible.json","odia_bible.json","punjabi_bible.json","sepedi_bible.json",
    "tamil_bible.json","telugu_bible.json","xhosa_bible.json","zulu_bible.json"
  ];

  const primarySel = document.getElementById('primarySel');
  const parallelSel = document.getElementById('parallelSel');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const refEl = document.getElementById('ref');
  const versesEl = document.getElementById('verses');

  // fill selects
  FILES.forEach(f => {
    const label = f.replace('.json','');
    primarySel.appendChild(new Option(label, f));
    parallelSel.appendChild(new Option(label, f));
  });

  // helpers
  function esc(s){ return (s===undefined||s===null)?'':String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function sortVerseKeys(keys){ return keys.sort((a,b)=> (parseInt(String(a).split('-')[0],10)||0) - (parseInt(String(b).split('-')[0],10)||0)); }

  function normalize(json){
    if(!json) return [];
    if(json.books && Array.isArray(json.books)){
      return json.books.map(b=>({
        name: b.name || b.book || 'Unknown',
        chapters: (b.chapters || []).map(ch => {
          if(Array.isArray(ch)) return ch.map((t,i)=> ({key:String(i+1), text:t}));
          if(typeof ch === 'object'){ const vk = sortVerseKeys(Object.keys(ch||{})); return vk.map(k=>({key:k, text: ch[k]})); }
          return [];
        })
      }));
    }
    const books = [];
    for(const bk of Object.keys(json||{})){
      const bookObj = json[bk];
      if(!bookObj || typeof bookObj !== 'object') continue;
      const chKeys = Object.keys(bookObj).sort((a,b)=> Number(a)-Number(b));
      const chapters = [];
      for(const ck of chKeys){
        const ch = bookObj[ck];
        if(!ch || typeof ch !== 'object'){ chapters.push([]); continue; }
        const vkeys = sortVerseKeys(Object.keys(ch));
        chapters.push(vkeys.map(k => ({ key: k, text: ch[k] })));
      }
      books.push({ name: bk, chapters });
    }
    return books;
  }

  // read URL params
  const params = new URLSearchParams(location.search);
  const urlVersion = params.get('version') || 'telugu_bible.json';
  let bookIndex = Number(params.get('bookIndex') || 0);
  let chapterIndex = Number(params.get('chapter') ? Number(params.get('chapter')) - 1 : 0);
  let verseParam = params.get('verse') || null;

  // caches
  const cacheNorm = {};

  async function loadVersionFile(fn){
    if(cacheNorm[fn]) return cacheNorm[fn];
    const res = await fetch(BASE + fn);
    const j = await res.json();
    const norm = normalize(j);
    cacheNorm[fn] = norm;
    return norm;
  }

  // set initial select values (if the file exists in list)
  if(FILES.includes(urlVersion)) primarySel.value = urlVersion;
  else primarySel.value = FILES[0];
  parallelSel.value = FILES[0];

  let primaryData = await loadVersionFile(primarySel.value);
  let parallelData = await loadVersionFile(parallelSel.value);

  function render(){
    const book = primaryData[bookIndex];
    const chapter = book ? (book.chapters[chapterIndex] || []) : [];
    refEl.textContent = `${book ? book.name : 'Unknown'} ${chapterIndex + 1}`;
    versesEl.innerHTML = '';
    // normalize verseParam numeric to key if needed
    let highlightKey = verseParam;
    if(highlightKey && /^\d+$/.test(highlightKey)){
      const idx = Number(highlightKey) - 1;
      if(chapter[idx]) highlightKey = chapter[idx].key;
    }
    for(let i=0;i<chapter.length;i++){
      const v = chapter[i];
      const primaryText = v.text || '';
      // find parallel verse with same key
      const pbook = parallelData[bookIndex];
      const pch = pbook ? (pbook.chapters[chapterIndex] || []) : [];
      const parObj = pch.find(x => x.key === v.key) || {};
      const parText = parObj.text || '';

      const block = document.createElement('div');
      block.className = 'verse-block' + (v.key === highlightKey ? ' active-verse' : '');
      block.innerHTML = `<div class="verse-num">Verse ${v.key}</div>
                         <div class="verse-primary">${esc(primaryText)}</div>
                         ${ parText ? `<div class="verse-parallel">${esc(parText)}</div>` : '' }`;
      // clicking opens index or further behavior (optional)
      block.onclick = ()=> {
        // open index at same location (optional) — currently keep as no-op or could open index
      };
      versesEl.appendChild(block);
    }

    // if verseParam is a range like "7-8" not found as key, join numeric range
    if(verseParam && verseParam.includes('-')){
      // if exact key exists we already handled; else show combined fallback
      const exactFound = chapter.some(v=> v.key === verseParam);
      if(!exactFound){
        const m = verseParam.match(/^(\d+)\s*-\s*(\d+)$/);
        if(m){
          const s = Math.max(1, Number(m[1])) - 1;
          const e = Math.max(1, Number(m[2])) - 1;
          const start = Math.max(0, Math.min(s, chapter.length-1));
          const end = Math.max(start, Math.min(e, chapter.length-1));
          // create a combined block at top
          const combinedText = chapter.slice(start, end+1).map(x=>x.text).join(' ');
          const combinedPar = (parallelData[bookIndex] && parallelData[bookIndex].chapters[chapterIndex]) ? parallelData[bookIndex].chapters[chapterIndex].slice(start,end+1).map(x=>x.text).join(' ') : '';
          const comb = document.createElement('div');
          comb.className = 'verse-block active-verse';
          comb.innerHTML = `<div class="verse-num">Verse ${chapter[start].key}${start!==end ? (' - ' + chapter[end].key) : ''}</div>
                            <div class="verse-primary">${esc(combinedText)}</div>
                            ${ combinedPar ? `<div class="verse-parallel">${esc(combinedPar)}</div>` : '' }`;
          versesEl.insertBefore(comb, versesEl.firstChild);
        }
      }
    }
  }

  // attach selects change handlers
  primarySel.onchange = async function(){
    primaryData = await loadVersionFile(this.value);
    render();
  };
  parallelSel.onchange = async function(){
    parallelData = await loadVersionFile(this.value);
    render();
  };

  // navigation: swipe + keys
  let stX = 0;
  document.addEventListener('touchstart', e => stX = e.changedTouches[0].clientX);
  document.addEventListener('touchend', e => {
    const dx = e.changedTouches[0].clientX - stX;
    if(Math.abs(dx) < 60) return;
    if(dx < 0) nextChapter();
    else prevChapter();
  });
  document.addEventListener('keydown', e => {
    if(e.key === 'ArrowRight') nextChapter();
    if(e.key === 'ArrowLeft') prevChapter();
  });

  function nextChapter(){
    const book = primaryData[bookIndex];
    if(!book) return;
    if(chapterIndex + 1 < book.chapters.length){ chapterIndex++; verseParam = null; render(); updateUrl(); }
  }
  function prevChapter(){
    if(chapterIndex - 1 >= 0){ chapterIndex--; verseParam = null; render(); updateUrl(); }
  }
  function updateUrl(){
    const p = new URLSearchParams();
    p.set('version', primarySel.value);
    p.set('bookIndex', bookIndex);
    p.set('chapter', chapterIndex + 1);
    history.replaceState(null, '', location.pathname + '?' + p.toString());
  }

  // TTS: alternate primary -> parallel -> primary...
  let ttsQueue = [];
  function buildTTSQueue(){
    ttsQueue = [];
    const primaryBook = primaryData[bookIndex];
    const pchapter = primaryBook ? (primaryBook.chapters[chapterIndex] || []) : [];
    const parallelBook = parallelData[bookIndex];
    const pchapter2 = parallelBook ? (parallelBook.chapters[chapterIndex] || []) : [];

    // If verseParam exact key exists, only queue that verse
    if(verseParam){
      // exact key
      const exactIndex = pchapter.findIndex(v => v.key === verseParam);
      if(exactIndex !== -1){
        ttsQueue.push({text: pchapter[exactIndex].text, index: exactIndex});
        if(pchapter2[exactIndex]) ttsQueue.push({text: pchapter2[exactIndex].text, index: exactIndex});
        return;
      }
      // range fallback numeric
      const m = verseParam.match(/^(\d+)\s*-\s*(\d+)$/);
      if(m){
        const s = Math.max(1, Number(m[1])) - 1;
        const e = Math.max(1, Number(m[2])) - 1;
        const start = Math.max(0, Math.min(s, pchapter.length-1));
        const end = Math.max(start, Math.min(e, pchapter.length-1));
        for(let i=start;i<=end;i++){
          ttsQueue.push({text: pchapter[i].text, index: i});
          if(pchapter2[i]) ttsQueue.push({text: pchapter2[i].text, index: i});
        }
        return;
      }
    }

    // default: full chapter
    for(let i=0;i<pchapter.length;i++){
      ttsQueue.push({text: pchapter[i].text, index: i});
      if(pchapter2[i]) ttsQueue.push({text: pchapter2[i].text, index: i});
    }
  }

  function speakNext(){
    if(ttsQueue.length === 0) return;
    const item = ttsQueue.shift();
    if(!item || !item.text) { setTimeout(speakNext, 120); return; }
    highlight(item.index);
    const u = new SpeechSynthesisUtterance(String(item.text));
    u.rate = 1.0;
    u.onend = ()=> setTimeout(speakNext, 120);
    u.onerror = ()=> setTimeout(speakNext, 180);
    speechSynthesis.speak(u);
  }

  function highlight(i){
    document.querySelectorAll('.verse-block').forEach(el=> el.classList.remove('active-verse'));
    const all = document.querySelectorAll('.verse-block');
    const el = all[i];
    if(el){ el.classList.add('active-verse'); el.scrollIntoView({behavior:'smooth', block:'center'}); }
  }

  playBtn.onclick = function(){
    speechSynthesis.cancel(); buildTTSQueue(); speakNext();
  };
  pauseBtn.onclick = function(){ if('speechSynthesis' in window) speechSynthesis.pause(); };
  resumeBtn.onclick = function(){ if('speechSynthesis' in window) speechSynthesis.resume(); };
  stopBtn.onclick = function(){ if('speechSynthesis' in window){ speechSynthesis.cancel(); ttsQueue = []; } };

  // initial render (use URL params version if provided)
  if(FILES.includes(urlVersion)) {
    // if urlVersion present (from params), set primarySel
    primarySel.value = urlVersion;
    primaryData = await loadAndCache(primarySel.value);
  }

  async function loadAndCache(fn){
    if(cache[fn]) return cache[fn];
    const res = await fetch(BASE + fn);
    const j = await res.json();
    const norm = normalize(j);
    cache[fn] = norm;
    return norm;
  }

  // small cache for read.html
  const cache = {};
  // primary and parallel already loaded above, but ensure consistent load if user switches selects
  primarySel.onchange = async function(){
    primaryData = await loadAndCache(this.value);
    // reset chapter/book if out of bounds
    if(!primaryData[bookIndex]) bookIndex = 0;
    if(!primaryData[bookIndex].chapters[chapterIndex]) chapterIndex = 0;
    render();
    updateUrl();
  };
  parallelSel.onchange = async function(){
    parallelData = await loadAndCache(this.value);
    render();
  };

  // initial load: ensure both data are loaded (already loaded above but safe)
  primaryData = primaryData || await loadAndCache(primarySel.value);
  parallelData = parallelData || await loadAndCache(parallelSel.value);
  render();

})();
</script>
</body>
</html>

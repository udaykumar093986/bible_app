<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Read — Bible Reader</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{--bg:#f7f9fc;--accent:#0b66c2;--border:#e2e8f0}
*{box-sizing:border-box}
body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);color:#222}
.header{background:#fff;padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
.header a{color:var(--accent);text-decoration:none;font-weight:700}
.container{max-width:980px;margin:18px auto;padding:0 16px}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:12px}
.select{padding:8px;border-radius:8px;border:1px solid var(--border);background:#fff}
.btn{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
.ref{font-size:20px;font-weight:700;color:var(--accent);margin-bottom:12px}
.verse-block{background:#fff;padding:14px;border-radius:10px;border:1px solid var(--border);margin-bottom:10px}
.verse-num{font-weight:700;margin-bottom:8px}
.verse-primary{font-family:"Noto Serif",serif;font-size:18px;line-height:1.7}
.verse-parallel{margin-top:10px;padding-left:14px;border-left:3px solid var(--accent);font-family:"Noto Serif",serif;font-size:17px;color:#2a3c55}
.active-verse{background:#fff8d1;border-color:#ffd56b}
.nav-inline{display:flex;gap:8px;align-items:center;margin-bottom:12px}
.small{padding:6px 8px;font-size:14px;border-radius:8px}
.note{margin-left:auto;color:#666}
@media(max-width:600px){.controls{flex-direction:column;align-items:stretch}.note{margin-left:0}}
</style>
</head>
<body>
  <div class="header">
    <a href="/">← Back</a>
    <div style="flex:1"></div>
    <div class="note">Swipe or drag left/right — Arrow keys also work</div>
  </div>

  <div class="container">
    <div class="controls">
      <select id="primarySel" class="select" aria-label="Primary version"></select>
      <select id="parallelSel" class="select" aria-label="Parallel version"></select>

      <button id="playBtn" class="btn">▶ Play</button>
      <button id="pauseBtn" class="btn">⏸ Pause</button>
      <button id="resumeBtn" class="btn">⏯ Resume</button>
      <button id="stopBtn" class="btn">⏹ Stop</button>

      <div style="width:12px"></div>

      <div id="verseNav" class="nav-inline" aria-hidden="true" style="display:none">
        <button id="prevVerse" class="small">◀ Prev Verse</button>
        <button id="nextVerse" class="small">Next Verse ▶</button>
        <button id="prevChapter" class="small">◀ Prev Chapter</button>
        <button id="nextChapter" class="small">Next Chapter ▶</button>
      </div>
    </div>

    <div id="ref" class="ref" role="heading" aria-level="1"></div>
    <div id="verses" tabindex="0"></div>
  </div>

<script>
(async function(){
  const BASE = "https://cdn.jsdelivr.net/gh/udaykumar093986/bibles@main/";
  // Put your actual filenames (must include .json)
  const FILES = [
    "telugu_bible.json","AMP_bible.json","KJV_bible.json","NIV_bible.json","ESV_bible.json",
    "NKJV_bible.json","NLT_bible.json"
    // add more filenames as hosted...
  ];

  // DOM
  const primarySel = document.getElementById('primarySel');
  const parallelSel = document.getElementById('parallelSel');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const refEl = document.getElementById('ref');
  const versesEl = document.getElementById('verses');
  const verseNav = document.getElementById('verseNav');
  const prevVerseBtn = document.getElementById('prevVerse');
  const nextVerseBtn = document.getElementById('nextVerse');
  const prevChapBtn = document.getElementById('prevChapter');
  const nextChapBtn = document.getElementById('nextChapter');

  // Fill selects (value is exact filename)
  FILES.forEach(f => {
    primarySel.appendChild(new Option(f, f));
    parallelSel.appendChild(new Option(f, f));
  });

  // Helpers
  function esc(s){ return String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function sortVerseKeys(keys){ return keys.sort((a,b)=>{ const A=parseInt(String(a).split('-')[0])||0; const B=parseInt(String(b).split('-')[0])||0; return A-B; }); }
  function normalize(json){
    if(!json) return [];
    if(json.books && Array.isArray(json.books)){
      return json.books.map(b=>({
        name: b.name || b.book || 'Unknown',
        chapters: (b.chapters||[]).map(ch=>{
          if(Array.isArray(ch)) return ch.map((t,i)=>({key:String(i+1), text:t}));
          if(typeof ch === 'object'){ const vk=sortVerseKeys(Object.keys(ch||{})); return vk.map(k=>({key:k, text:ch[k]})); }
          return [];
        })
      }));
    }
    const books=[];
    for(const bk of Object.keys(json||{})){
      const bookObj = json[bk];
      const chKeys = Object.keys(bookObj||{}).sort((a,b)=>Number(a)-Number(b));
      const chapters = [];
      chKeys.forEach(ck=>{
        const ch = bookObj[ck];
        if(!ch || typeof ch !== 'object'){ chapters.push([]); return; }
        const vkeys = sortVerseKeys(Object.keys(ch||{}));
        chapters.push(vkeys.map(k=>({key:k, text: ch[k]})));
      });
      books.push({name: bk, chapters});
    }
    return books;
  }

  // Read URL params
  const params = new URLSearchParams(location.search);
  let initialVersion = params.get('version') || 'telugu_bible.json';
  if(!initialVersion.endsWith('.json')) initialVersion += '.json';
  let bookIndex = Number(params.get('bookIndex') || 0);
  let chapterIndex = params.get('chapter') ? Number(params.get('chapter'))-1 : 0;
  let verseParam = params.get('verse') || null; // e.g., "7" or "7-8" or "7-8,10" not supported (only single/range)
  if(verseParam) verseParam = verseParam.trim();

  // set selects
  if(FILES.includes(initialVersion)) primarySel.value = initialVersion;
  else primarySel.value = FILES[0];
  parallelSel.value = FILES.includes(params.get('parallel') ? (params.get('parallel').endsWith('.json') ? params.get('parallel') : params.get('parallel') + '.json') : FILES[1]) ? (params.get('parallel') ? (params.get('parallel').endsWith('.json') ? params.get('parallel') : params.get('parallel') + '.json') : FILES[1]) : FILES[1];

  // caches
  const cache = {};
  async function loadFile(fn){
    if(cache[fn]) return cache[fn];
    const r = await fetch(BASE + fn);
    if(!r.ok) throw new Error('Fetch failed ' + r.status + ' for ' + fn);
    const j = await r.json();
    const norm = normalize(j);
    cache[fn] = norm;
    return norm;
  }

  // Load primary & parallel
  let primaryBible = await loadFile(primarySel.value);
  let parallelBible = await loadFile(parallelSel.value);

  // Current view helpers
  function currentBook(){ return primaryBible[bookIndex]; }
  function currentChapter(){ const b = currentBook(); return b ? (b.chapters[chapterIndex] || []) : []; }

  // Rendering - show only verse if verseParam provided (A behavior)
  function render(){
    const book = currentBook();
    if(!book){ refEl.textContent = 'No data'; versesEl.innerHTML=''; return; }
    const chapter = currentChapter();
    refEl.textContent = `${book.name} ${chapterIndex+1}`;

    versesEl.innerHTML = '';

    // If verseParam is present, show only that verse or combined range
    if(verseParam){
      // try exact key match first: supports "7-8"
      const exactIndex = chapter.findIndex(v => v.key === verseParam);
      if(exactIndex !== -1){
        // render just this verse (with parallel if exists)
        const v = chapter[exactIndex];
        const par = (parallelBible[bookIndex] && parallelBible[bookIndex].chapters[chapterIndex]) ? parallelBible[bookIndex].chapters[chapterIndex].find(x=>x.key===v.key) : null;
        const block = document.createElement('div');
        block.className = 'verse-block active-verse';
        block.innerHTML = `<div class="verse-num">Verse ${v.key}</div>
                           <div class="verse-primary">${esc(v.text)}</div>
                           ${par && par.text ? `<div class="verse-parallel">${esc(par.text)}</div>` : ''}`;
        versesEl.appendChild(block);
        showVerseNav(true, exactIndex);
        return;
      }

      // if it's a numeric range like 7-8 or single number "7"
      const mRange = verseParam.match(/^(\d+)\s*-\s*(\d+)$/);
      if(mRange){
        const s = Math.max(1, Number(mRange[1])) - 1;
        const e = Math.max(1, Number(mRange[2])) - 1;
        const start = Math.max(0, Math.min(s, chapter.length-1));
        const end = Math.max(start, Math.min(e, chapter.length-1));
        // combined primary text
        const combinedPrimary = chapter.slice(start, end+1).map(x=>x.text).join(' ');
        const parCh = (parallelBible[bookIndex] && parallelBible[bookIndex].chapters[chapterIndex]) ? parallelBible[bookIndex].chapters[chapterIndex] : [];
        const combinedParallel = parCh.slice(start, end+1).map(x=>x.text).join(' ');
        const block = document.createElement('div');
        block.className = 'verse-block active-verse';
        block.innerHTML = `<div class="verse-num">Verse ${chapter[start].key}${start!==end?('-'+chapter[end].key):''}</div>
                           <div class="verse-primary">${esc(combinedPrimary)}</div>
                           ${ combinedParallel ? `<div class="verse-parallel">${esc(combinedParallel)}</div>`:'' }`;
        versesEl.appendChild(block);
        showVerseNav(true, start);
        return;
      }

      // if single numeric "7" but keys are like "7" or "7-8" not exact, try by index
      if(/^\d+$/.test(verseParam)){
        const idx = Math.max(0, Math.min(Number(verseParam)-1, chapter.length-1));
        const v = chapter[idx];
        if(v){
          const par = (parallelBible[bookIndex] && parallelBible[bookIndex].chapters[chapterIndex]) ? parallelBible[bookIndex].chapters[chapterIndex].find(x=>x.key===v.key) : null;
          const block = document.createElement('div');
          block.className = 'verse-block active-verse';
          block.innerHTML = `<div class="verse-num">Verse ${v.key}</div>
                             <div class="verse-primary">${esc(v.text)}</div>
                             ${par && par.text ? `<div class="verse-parallel">${esc(par.text)}</div>` : ''}`;
          versesEl.appendChild(block);
          showVerseNav(true, idx);
          return;
        }
      }

      // fallback: not found -> show a message
      versesEl.innerHTML = `<div style="padding:12px;color:#666">Selected verse not found in this chapter.</div>`;
      showVerseNav(false);
      return;
    }

    // Otherwise show full chapter (stacked primary -> parallel per verse)
    for(let i=0;i<chapter.length;i++){
      const v = chapter[i];
      const par = (parallelBible[bookIndex] && parallelBible[bookIndex].chapters[chapterIndex]) ? parallelBible[bookIndex].chapters[chapterIndex].find(x=>x.key===v.key) : null;
      const block = document.createElement('div');
      block.className = 'verse-block' + (false ? ' active-verse' : '');
      block.innerHTML = `<div class="verse-num">Verse ${v.key}</div>
                         <div class="verse-primary">${esc(v.text)}</div>
                         ${ par && par.text ? `<div class="verse-parallel">${esc(par.text)}</div>` : '' }`;
      versesEl.appendChild(block);
    }
    showVerseNav(false);
  }

  // Verse navigation buttons visibility & index tracking
  let currentVerseIndex = null; // used when verseParam present
  function showVerseNav(show, idx=null){
    if(show){
      verseNav.style.display = 'flex';
      verseNav.setAttribute('aria-hidden','false');
      currentVerseIndex = (typeof idx === 'number') ? idx : 0;
    } else {
      verseNav.style.display = 'none';
      verseNav.setAttribute('aria-hidden','true');
      currentVerseIndex = null;
    }
  }

  // update URL (preserve .json names)
  function updateUrl(replace=false){
    const p = new URLSearchParams();
    p.set('version', primarySel.value);
    p.set('bookIndex', bookIndex);
    p.set('chapter', chapterIndex+1);
    if(verseParam) p.set('verse', verseParam);
    const url = location.pathname + '?' + p.toString();
    if(replace) history.replaceState(null,'',url); else history.pushState(null,'',url);
  }

  // Selection change handlers
  primarySel.onchange = async function(){
    primaryBible = await loadFileSafe(this.value);
    // clamp indices
    if(bookIndex >= primaryBible.length) bookIndex = 0;
    if(chapterIndex >= (primaryBible[bookIndex] ? primaryBible[bookIndex].chapters.length : 1)) chapterIndex = 0;
    render();
    updateUrl(true);
  };
  parallelSel.onchange = async function(){ parallelBible = await loadFileSafe(this.value); render(); };

  // loadFile w/ error handling
  async function loadFileSafe(fn){
    try{ return await loadFile(fn); } catch(e){ alert('Failed to load ' + fn); return []; }
  }

  async function loadFile(fn){
    if(!fn.endsWith('.json')) fn += '.json';
    if(cache[fn]) return cache[fn];
    const r = await fetch(BASE + fn);
    if(!r.ok) throw new Error('Fetch failed ' + r.status);
    const j = await r.json();
    const norm = normalize(j);
    cache[fn] = norm;
    return norm;
  }

  // Navigation helpers (chapters & verses)
  function gotoChapter(bi,ci, push=true){
    bookIndex = bi;
    chapterIndex = ci;
    verseParam = null;
    render();
    updateUrl(!push);
  }
  function gotoVerseByIndex(idx){
    const chapter = currentChapter();
    if(!chapter || idx<0 || idx>=chapter.length) return;
    verseParam = chapter[idx].key;
    render();
    updateUrl();
  }
  function gotoNextVerse(){
    if(currentVerseIndex === null) return;
    const chapter = currentChapter();
    if(currentVerseIndex + 1 < chapter.length){ gotoVerseByIndex(currentVerseIndex+1); }
    else { // next chapter first verse
      if(chapterIndex+1 < currentBook().chapters.length){ chapterIndex++; currentVerseIndex = 0; gotoVerseByIndex(0); }
    }
  }
  function gotoPrevVerse(){
    if(currentVerseIndex === null) return;
    if(currentVerseIndex - 1 >= 0){ gotoVerseByIndex(currentVerseIndex-1); }
    else { // prev chapter last verse
      if(chapterIndex - 1 >=0){ chapterIndex--; const ch = currentChapter(); gotoVerseByIndex(ch.length-1); }
    }
  }

  prevVerseBtn.onclick = ()=> gotoPrevVerse();
  nextVerseBtn.onclick = ()=> gotoNextVerse();
  prevChapBtn.onclick = ()=> { if(chapterIndex-1>=0){ chapterIndex--; verseParam=null; render(); updateUrl(); } };
  nextChapBtn.onclick = ()=> { if(chapterIndex+1 < currentBook().chapters.length){ chapterIndex++; verseParam=null; render(); updateUrl(); } };

  // Swipe & mouse-drag detection
  let touchStartX = 0;
  let mouseDown = false;
  let mouseStartX = 0;
  let mouseCurrentX = 0;

  document.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].clientX; });
  document.addEventListener('touchend', e => {
    const dx = e.changedTouches[0].clientX - touchStartX;
    if(Math.abs(dx) < 60) return;
    if(dx < 0) nextChapter(); else prevChapter();
  });

  // Mouse drag for desktop
  versesEl.addEventListener('mousedown', e => { mouseDown = true; mouseStartX = e.clientX; });
  document.addEventListener('mousemove', e => { if(!mouseDown) return; mouseCurrentX = e.clientX; });
  document.addEventListener('mouseup', e => {
    if(!mouseDown) return;
    mouseDown = false;
    const dx = (mouseCurrentX || e.clientX) - mouseStartX;
    if(Math.abs(dx) < 80) return;
    if(dx < 0) nextChapter(); else prevChapter();
    mouseStartX = mouseCurrentX = 0;
  });

  // Arrow keys
  document.addEventListener('keydown', e => {
    if(e.key === 'ArrowRight') nextChapter();
    if(e.key === 'ArrowLeft') prevChapter();
    if(e.key === 'PageDown') nextChapter();
    if(e.key === 'PageUp') prevChapter();
  });

  function nextChapter(){
    const b = currentBook();
    if(!b) return;
    if(chapterIndex + 1 < b.chapters.length){ chapterIndex++; verseParam = null; render(); updateUrl(); }
  }
  function prevChapter(){
    if(chapterIndex - 1 >= 0){ chapterIndex--; verseParam = null; render(); updateUrl(); }
  }

  // TTS queue: Primary then Parallel alternating
  let ttsQueue = [];
  function buildTTSQueue(){
    ttsQueue = [];
    const ch = currentChapter();
    const pb = (parallelBible[bookIndex] && parallelBible[bookIndex].chapters[chapterIndex]) ? parallelBible[bookIndex].chapters[chapterIndex] : [];
    if(verseParam){
      // exact match or numeric range handled in render - build same queue
      const exactIndex = ch.findIndex(v => v.key === verseParam);
      if(exactIndex !== -1){
        ttsQueue.push({text: ch[exactIndex].text, idx: exactIndex});
        if(pb[exactIndex]) ttsQueue.push({text: pb[exactIndex].text, idx: exactIndex});
        return;
      }
      const m = verseParam.match(/^(\d+)\s*-\s*(\d+)$/);
      if(m){
        const s = Math.max(1, Number(m[1])) - 1;
        const e = Math.max(1, Number(m[2])) - 1;
        const start = Math.max(0, Math.min(s, ch.length-1));
        const end = Math.max(start, Math.min(e, ch.length-1));
        for(let i=start;i<=end;i++){
          ttsQueue.push({text: ch[i].text, idx: i});
          if(pb[i]) ttsQueue.push({text: pb[i].text, idx: i});
        }
        return;
      }
      // numeric single fallback
      if(/^\d+$/.test(verseParam)){
        const idx = Math.max(0, Math.min(Number(verseParam)-1, ch.length-1));
        ttsQueue.push({text: ch[idx].text, idx});
        if(pb[idx]) ttsQueue.push({text: pb[idx].text, idx});
        return;
      }
      // otherwise nothing
      return;
    }
    // full chapter
    for(let i=0;i<ch.length;i++){
      ttsQueue.push({text: ch[i].text, idx:i});
      if(pb[i]) ttsQueue.push({text: pb[i].text, idx:i});
    }
  }

  function speakNext(){
    if(ttsQueue.length === 0) return;
    const item = ttsQueue.shift();
    if(!item || !item.text) return setTimeout(speakNext,120);
    // highlight
    const blocks = document.querySelectorAll('.verse-block');
    blocks.forEach(el => el.classList.remove('active-verse'));
    if(blocks[item.idx]){ blocks[item.idx].classList.add('active-verse'); blocks[item.idx].scrollIntoView({behavior:'smooth', block:'center'}); }
    const utt = new SpeechSynthesisUtterance(String(item.text));
    utt.rate = 1.0;
    utt.onend = ()=> setTimeout(speakNext,120);
    utt.onerror = ()=> setTimeout(speakNext,180);
    speechSynthesis.speak(utt);
  }

  playBtn.onclick = ()=> { speechSynthesis.cancel(); buildTTSQueue(); speakNext(); };
  pauseBtn.onclick = ()=> { try{ speechSynthesis.pause(); }catch(e){} };
  resumeBtn.onclick = ()=> { try{ speechSynthesis.resume(); }catch(e){} };
  stopBtn.onclick = ()=> { try{ speechSynthesis.cancel(); ttsQueue = []; }catch(e){} };

  // Popstate handling (back/forward)
  window.addEventListener('popstate', ()=> {
    const p = new URLSearchParams(location.search);
    const v = p.get('version'); if(v) primarySel.value = v.endsWith('.json')?v:(v+'.json');
    bookIndex = Number(p.get('bookIndex') || 0);
    chapterIndex = p.get('chapter') ? Number(p.get('chapter'))-1 : 0;
    verseParam = p.get('verse') || null;
    (async()=>{ primaryBible = await loadFileSafe(primarySel.value); parallelBible = await loadFileSafe(parallelSel.value); render(); })();
  });

  // Initial render (ensure files loaded)
  primaryBible = await loadFileSafe(primarySel.value);
  parallelBible = await loadFileSafe(parallelSel.value);

  render();

  // Expose small helper for index to deep-link if needed
  window.openRead = function(paramsObj){
    const p = new URLSearchParams(paramsObj);
    location.href = 'read.html?' + p.toString();
  };

})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bible Reader — SPA</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#f7f9fc; --accent:#0b66c2; --border:#e2e8f0;
  --highlight:#fff8d1; --soft:#f4f8ff;
}
*{box-sizing:border-box;margin:0;padding:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
body{background:var(--bg);color:#1d2d35;-webkit-font-smoothing:antialiased;min-height:100vh}

/* header */
.header{
  padding:14px 20px;background:#fff;border-bottom:1px solid var(--border);
  display:flex;justify-content:space-between;align-items:center;position:sticky;top:0;z-index:100;
}
.brand{font-size:22px;font-weight:700;color:var(--accent)}
.meta{font-size:14px;color:#466}

/* layout */
.app{max-width:1100px;margin:18px auto;padding:0 18px}
.controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin:14px 0}
select,input{padding:12px;border-radius:10px;border:1px solid var(--border);background:#fff;font-size:14px}
button{border:0;background:var(--accent);color:#fff;padding:10px 16px;border-radius:10px;font-weight:600;cursor:pointer;font-size:14px}

/* jump */
.jump-container{background:#fff;border-radius:12px;border:1px solid var(--border);margin-bottom:18px;overflow:hidden}
.jump-header{padding:14px 16px;background:var(--soft);cursor:pointer;font-weight:700;color:var(--accent)}
.jump-body{display:none;padding:14px;background:#fff}
.jump-body select{min-width:140px;margin-right:8px;padding:10px;border-radius:8px;border:1px solid var(--border)}
.jump-body input.range{min-width:160px;padding:10px;border-radius:8px;border:1px solid var(--border);margin-right:8px}

/* panes */
.panes{display:grid;grid-template-columns:1fr;gap:16px}
.list-pane{background:#fff;border:1px solid var(--border);border-radius:12px;padding:16px}
.reader-pane{display:none;background:#fff;border:1px solid var(--border);border-radius:12px;padding:16px}

/* reader */
.reader-top{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
.select{padding:8px;border-radius:8px;border:1px solid var(--border);background:#fff}
.btn{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
.ref{font-size:22px;font-weight:700;color:var(--accent);margin-bottom:12px}
.verse-block{background:#fff;padding:14px;border-radius:12px;border:1px solid var(--border);margin-bottom:12px}
.verse-num{font-weight:700;margin-bottom:8px;color:#345}
.verse-primary{font-family:"Noto Serif",serif;font-size:18px;line-height:1.7}
.verse-parallel{margin-top:10px;padding-left:14px;border-left:3px solid var(--accent);font-family:"Noto Serif",serif;font-size:17px;color:#2a3c55}
.active-verse{background:var(--highlight);border-color:#dccb6e}

/* search items */
.search-item{padding:12px;border-radius:10px;border:1px solid var(--border);background:white;margin-bottom:10px;cursor:pointer}
.highlight{background:#fff3c4;padding:2px;border-radius:4px}

/* nav */
.nav-row{display:flex;gap:8px;align-items:center;margin:10px 0;flex-wrap:wrap}
.small{padding:6px 10px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}

/* notice */
.notice{position:fixed;top:80px;left:20px;right:20px;padding:12px;border-radius:10px;background:white;border:1px solid var(--border);text-align:center;display:none;z-index:400}

/* responsive */
@media(min-width:900px){ .panes{grid-template-columns:1fr 1fr} }
@media(max-width:720px){ .controls select,input{width:100%} .jump-body{display:block} }
</style>
</head>
<body>
  <header class="header">
    <div class="brand">Bible Reader</div>
    <div class="meta">PARALLEL • SEARCH • SPA</div>
  </header>

  <div class="app">
    <!-- controls -->
    <div class="controls" id="topControls">
      <select id="primarySelect" aria-label="Primary version"><option value="">PRIMARY VERSION</option></select>
      <select id="parallelSelect" aria-label="Parallel version"><option value="">PARALLEL VERSION</option></select>
      <button id="openBtn">Open (first book)</button>
      <input id="searchBox" placeholder="Search Text…" style="min-width:200px" />
      <button id="searchBtn">Search</button>
    </div>

    <!-- jump -->
    <div class="jump-container">
      <div class="jump-header" id="jumpToggle">▼ Jump to Book / Chapter / Verse</div>
      <div class="jump-body" id="jumpBody" aria-hidden="true">
        <select id="bookSelect" aria-label="Book"><option value="">Book</option></select>
        <select id="chapterSelect" aria-label="Chapter"><option value="">Chapter</option></select>
        <select id="verseSelect" aria-label="Verse"><option value="">Verse</option></select>
        <input id="verseRange" class="range" placeholder="Verse or range (e.g. 7 or 7-8)" />
        <button id="jumpGo">Go</button>
      </div>
    </div>

    <!-- panes: list/search on left, reader on right for wide screens -->
    <div class="panes">
      <div class="list-pane" id="listPane">
        <div id="listHeader" style="margin-bottom:12px;font-weight:700">Search results & quick open</div>
        <div id="searchInfo" style="margin-bottom:6px;color:#666"></div>
        <div id="searchResults"></div>
        <div style="height:18px"></div>
        <div id="booksPreview"></div>
      </div>

      <div class="reader-pane" id="readerPane" aria-hidden="true">
        <div class="reader-top">
          <select id="primarySelReader" class="select" aria-label="Primary reader version"></select>
          <select id="parallelSelReader" class="select" aria-label="Parallel reader version"></select>

          <button id="ttsPlay" class="btn">▶ Play</button>
          <button id="ttsPause" class="btn">⏸ Pause</button>
          <button id="ttsResume" class="btn">⏯ Resume</button>
          <button id="ttsStop" class="btn">⏹ Stop</button>

          <div style="flex:1"></div>
          <div style="font-size:13px;color:#666">Swipe / Drag / Arrow keys</div>
        </div>

        <div class="nav-row" id="readerNav" style="display:none">
          <button id="prevVerse" class="small">◀ Prev Verse</button>
          <button id="nextVerse" class="small">Next Verse ▶</button>
          <button id="prevChapter" class="small">◀ Prev Chapter</button>
          <button id="nextChapter" class="small">Next Chapter ▶</button>
        </div>

        <div id="currentRef" class="ref"></div>
        <div id="versesContainer"></div>
      </div>
    </div>
  </div>

  <div id="notice" class="notice" role="status" aria-live="polite"></div>

<script>
/* SPA index.html — combined listing + reader in same page.
   Navigation uses history.pushState so links are shareable.
   All features from previous index + read are preserved.
*/

(async function(){
  const BASE = "https://cdn.jsdelivr.net/gh/udaykumar093986/bibles@main/";
  const FILES = [
"AMP_bible.json","CSB_bible.json","ESV_bible.json","KJV_bible.json",
"NIV_bible.json","NKJV_bible.json","NLT_bible.json","afrikaans_bible.json",
"bengali_bible.json","gujarati_bible.json","hindi_bible.json",
"hungarian_bible.json","indonesian_bible.json","kannada_bible.json",
"malayalam_bible.json","marathi_bible.json","nepali_bible.json",
"odia_bible.json","punjabi_bible.json","sepedi_bible.json",
"tamil_bible.json","telugu_bible.json","xhosa_bible.json","zulu_bible.json"
  ];

  // DOM refs
  const primarySelect = document.getElementById("primarySelect");
  const parallelSelect = document.getElementById("parallelSelect");
  const openBtn = document.getElementById("openBtn");
  const searchBox = document.getElementById("searchBox");
  const searchBtn = document.getElementById("searchBtn");
  const jumpToggle = document.getElementById("jumpToggle");
  const jumpBody = document.getElementById("jumpBody");
  const bookSelect = document.getElementById("bookSelect");
  const chapterSelect = document.getElementById("chapterSelect");
  const verseSelect = document.getElementById("verseSelect");
  const verseRange = document.getElementById("verseRange");
  const jumpGo = document.getElementById("jumpGo");
  const searchInfo = document.getElementById("searchInfo");
  const searchResults = document.getElementById("searchResults");
  const booksPreview = document.getElementById("booksPreview");
  const listPane = document.getElementById("listPane");
  const readerPane = document.getElementById("readerPane");

  const primarySelReader = document.getElementById("primarySelReader");
  const parallelSelReader = document.getElementById("parallelSelReader");
  const ttsPlay = document.getElementById("ttsPlay");
  const ttsPause = document.getElementById("ttsPause");
  const ttsResume = document.getElementById("ttsResume");
  const ttsStop = document.getElementById("ttsStop");
  const currentRef = document.getElementById("currentRef");
  const versesContainer = document.getElementById("versesContainer");
  const readerNav = document.getElementById("readerNav");
  const prevVerse = document.getElementById("prevVerse");
  const nextVerse = document.getElementById("nextVerse");
  const prevChapter = document.getElementById("prevChapter");
  const nextChapter = document.getElementById("nextChapter");

  const notice = document.getElementById("notice");

  // populate version selects (display cleaned uppercase)
  FILES.forEach(f=>{
    const label = f.replace("_bible.json","").replace(".json","").toUpperCase();
    primarySelect.appendChild(new Option(label, f));
    parallelSelect.appendChild(new Option(label, f));
    primarySelReader.appendChild(new Option(label, f));
    parallelSelReader.appendChild(new Option(label, f));
  });

  function showNotice(msg,ms=1200){ notice.textContent = msg; notice.style.display="block"; setTimeout(()=> notice.style.display="none", ms); }
  function esc(s){ return (s===undefined||s===null)?'':String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function sortVerseKeys(keys){ return keys.sort((a,b)=> (parseInt(String(a).split('-')[0])||0) - (parseInt(String(b).split('-')[0])||0)); }

  // Normalizer supports both array-shape and object-shape JSON
  function normalize(json){
    if(!json) return {books:[]};
    if(json.books && Array.isArray(json.books)){
      return { books: json.books.map(b=>({
        name: b.name || b.book || "Unknown",
        chapters: (b.chapters || []).map(ch=>{
          if(Array.isArray(ch)) return ch.map((t,i)=>({key:String(i+1), text:t}));
          if(typeof ch==='object'){ const vk = sortVerseKeys(Object.keys(ch||{})); return vk.map(k=>({key:k, text: ch[k]})); }
          return [];
        })
      }))};
    }
    const books=[];
    for(const bookName of Object.keys(json||{})){
      const bookObj = json[bookName];
      if(!bookObj || typeof bookObj !== 'object') continue;
      const chKeys = Object.keys(bookObj).sort((a,b)=>Number(a)-Number(b));
      const chapters = [];
      for(const ck of chKeys){
        const ch = bookObj[ck];
        if(!ch || typeof ch !== 'object'){ chapters.push([]); continue; }
        const vkeys = sortVerseKeys(Object.keys(ch));
        chapters.push(vkeys.map(k=>({key:k, text: ch[k]})));
      }
      books.push({ name: bookName, chapters });
    }
    return { books };
  }

  // cache
  const bibleRaw = {};
  const bibleNorm = {};
  function ensureJsonFilename(v){ return v && v.endsWith('.json') ? v : (v? v + '.json' : v); }

  async function fetchAndNormalize(file){
    if(!file) throw new Error("No file");
    if(bibleNorm[file]) return bibleNorm[file];
    const res = await fetch(BASE + file);
    if(!res.ok) throw new Error("Fetch failed: " + res.status + " for " + file);
    const j = await res.json();
    bibleRaw[file] = j;
    const norm = normalize(j);
    bibleNorm[file] = norm;
    return norm;
  }

  // search index lazy cache
  const searchIndexCache = {};

  function buildSearchIndexFor(file, norm){
    if(searchIndexCache[file]) return searchIndexCache[file];
    const arr=[];
    norm.books.forEach((b,bi)=>{
      b.chapters.forEach((ch,ci)=>{
        ch.forEach((v,vi)=>{
          const t = (v && v.text) ? v.text : "";
          arr.push({bookIndex:bi, chapterIndex:ci, verseIndex:vi, book: b.name, chapter: ci+1, verseKey: v.key, text:t, low: t.toLowerCase()});
        });
      });
    });
    searchIndexCache[file] = arr;
    return arr;
  }

  // SPA state
  let state = {
    view: 'list', // 'list' or 'read'
    version: null,
    parallel: null,
    bookIndex: 0,
    chapter: 0,
    verse: null
  };

  // parse initial URL params
  function readUrlToState(){
    const p = new URLSearchParams(location.search);
    const ver = ensureJsonFilename(p.get('version')) || FILES.find(f=>f.includes('telugu')) || FILES[0];
    state.version = ver;
    state.parallel = ensureJsonFilename(p.get('parallel')) || null;
    state.bookIndex = Number(p.get('bookIndex') || 0);
    state.chapter = Number(p.get('chapter') ? Number(p.get('chapter')) - 1 : 0);
    state.verse = p.get('verse') || null;
    state.view = p.get('view') === 'read' || p.get('chapter') ? 'read' : 'list';
  }
  readUrlToState();

  // view rendering
  function showList(){
    readerPane.style.display = 'none';
    listPane.style.display = 'block';
    // update top controls to reflect state
    primarySelect.value = state.version || '';
    parallelSelect.value = state.parallel || '';
    // adjust reader header selects too
    primarySelReader.value = state.version || '';
    parallelSelReader.value = state.parallel || '';
    document.getElementById('currentRef').textContent = '';
  }

  function showReader(){
    listPane.style.display = 'none';
    readerPane.style.display = 'block';
    // sync selects
    primarySelReader.value = state.version || primarySelect.value || '';
    parallelSelReader.value = state.parallel || parallelSelect.value || '';
  }

  // navigate SPA and push history
  async function navigateToRead(push=true){
    state.view = 'read';
    // ensure defaults
    if(!state.version) state.version = primarySelect.value || FILES[0];
    if(!state.parallel) state.parallel = parallelSelect.value || null;
    // fetch versions
    try{
      await fetchAndNormalize(state.version);
      if(state.parallel) await fetchAndNormalize(state.parallel);
    }catch(e){
      showNotice('Load failed: ' + e.message, 2000);
      return;
    }
    renderReader();
    showReader();
    const p = new URLSearchParams();
    p.set('view','read');
    p.set('version', state.version);
    if(state.parallel) p.set('parallel', state.parallel);
    p.set('bookIndex', String(state.bookIndex));
    p.set('chapter', String(state.chapter + 1));
    if(state.verse) p.set('verse', state.verse);
    const url = '?' + p.toString();
    if(push) history.pushState({...state}, '', url);
    else history.replaceState({...state}, '', url);
  }

  function navigateToList(push=true){
    state.view = 'list';
    showList();
    const p = new URLSearchParams();
    p.set('view','list');
    if(state.version) p.set('version', state.version);
    const url = '?' + p.toString();
    if(push) history.pushState({...state}, '', url);
    else history.replaceState({...state}, '', url);
  }

  // render a small preview of books for the selected primary version
  async function renderBooksPreview(){
    booksPreview.innerHTML = '';
    if(!state.version) return;
    const norm = await fetchAndNormalize(state.version);
    const frag = document.createDocumentFragment();
    norm.books.slice(0,30).forEach((b,bi)=>{
      const div = document.createElement('div');
      div.style.padding = '6px 0';
      div.style.borderBottom = '1px solid #f0f3f6';
      div.innerHTML = `<strong>${esc(b.name)}</strong> — ${b.chapters.length} chapters
        <div style="margin-top:6px"><button class="small" data-bi="${bi}">Open 1</button></div>`;
      frag.appendChild(div);
    });
    booksPreview.appendChild(frag);
    // attach open buttons
    booksPreview.querySelectorAll('button.small').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const bi = Number(e.target.getAttribute('data-bi'));
        state.bookIndex = bi; state.chapter = 0; state.verse = null; state.version = state.version || primarySelect.value || FILES[0];
        navigateToRead();
      });
    });
  }

  // SEARCH
  searchBtn.onclick = async function(){
    const q = (searchBox.value || '').trim().toLowerCase();
    searchResults.innerHTML = ''; searchInfo.textContent = '';
    if(!q) return;
    const file = primarySelect.value || state.version || FILES[0];
    try{
      const norm = await fetchAndNormalize(file);
      const idx = buildSearchIndexFor(file, norm);
      const res = [];
      for(let i=0;i<idx.length && res.length<200;i++){
        if(idx[i].low.includes(q)) res.push(idx[i]);
      }
      searchInfo.textContent = `Found ${res.length}`;
      if(!res.length){ searchResults.innerHTML = '<div style="padding:8px;color:#666">No results</div>'; return; }
      const safe = q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
      const re = new RegExp(safe, 'ig');
      const frag = document.createDocumentFragment();
      res.forEach(r=>{
        const div = document.createElement('div');
        div.className = 'search-item';
        const primarySnippet = esc(r.text).replace(re, m=>`<span class="highlight">${m}</span>`);
        div.innerHTML = `<strong>${esc(r.book)} ${r.chapter}:${r.verseKey}</strong>
          <div style="margin-top:6px">${primarySnippet}</div>
          <small style="display:block;margin-top:6px;color:#666">Click to open</small>`;
        div.onclick = () => {
          state.version = file;
          state.bookIndex = r.bookIndex;
          state.chapter = r.chapterIndex;
          state.verse = r.verseKey;
          state.parallel = parallelSelect.value || null;
          navigateToRead();
        };
        frag.appendChild(div);
      });
      searchResults.appendChild(frag);
    }catch(e){
      showNotice('Search failed: ' + e.message, 2000);
    }
  };

  // JUMP UI
  jumpToggle.onclick = ()=> {
    const show = jumpBody.style.display === 'block';
    jumpBody.style.display = show ? 'none' : 'block';
    jumpBody.setAttribute('aria-hidden', show ? 'true' : 'false');
  };

  primarySelect.onchange = async function(){
    const file = this.value;
    if(!file) return;
    state.version = file;
    state.parallel = state.parallel || null;
    // populate books
    try{
      const norm = await fetchAndNormalize(file);
      bookSelect.innerHTML = "<option value=''>Book</option>";
      norm.books.forEach((b,i)=> bookSelect.appendChild(new Option(b.name, i)));
      chapterSelect.innerHTML = "<option value=''>Chapter</option>";
      verseSelect.innerHTML = "<option value=''>Verse</option>";
      showNotice('Loaded ' + this.options[this.selectedIndex].text, 900);
      await renderBooksPreview();
    }catch(e){
      showNotice('Load failed', 1000);
    }
  };

  bookSelect.onchange = function(){
    state.bookIndex = Number(this.value || 0);
    chapterSelect.innerHTML = "<option value=''>Chapter</option>";
    verseSelect.innerHTML = "<option value=''>Verse</option>";
    const file = state.version || primarySelect.value;
    if(!file) return;
    fetchAndNormalize(file).then(norm=>{
      const chCount = norm.books[state.bookIndex].chapters.length;
      for(let c=1;c<=chCount;c++) chapterSelect.appendChild(new Option(c, c-1));
    }).catch(()=>{});
  };

  chapterSelect.onchange = function(){
    state.chapter = Number(this.value || 0);
    verseSelect.innerHTML = "<option value=''>Verse</option>";
    const file = state.version || primarySelect.value;
    if(!file) return;
    fetchAndNormalize(file).then(norm=>{
      const verses = norm.books[state.bookIndex].chapters[state.chapter].length;
      for(let v=1; v<=verses; v++) verseSelect.appendChild(new Option(v, v-1));
    }).catch(()=>{});
  };

  jumpGo.onclick = function(){
    if(!primarySelect.value && !state.version){ showNotice('Select primary version'); return; }
    const file = primarySelect.value || state.version;
    state.version = file;
    state.bookIndex = bookSelect.value !== '' ? Number(bookSelect.value) : state.bookIndex;
    state.chapter = chapterSelect.value !== '' ? Number(chapterSelect.value) : state.chapter;
    const rangeInput = (verseRange.value || '').trim();
    const viDropdown = verseSelect.value !== '' ? Number(verseSelect.value) : null;
    if(rangeInput) state.verse = rangeInput;
    else if(viDropdown !== null) state.verse = String(viDropdown + 1);
    else state.verse = null;
    state.parallel = parallelSelect.value || null;
    navigateToRead();
  };

  // render reader
  async function renderReader(){
    // fetch primary/parallel
    const file = state.version || primarySelect.value || FILES[0];
    const pFile = state.parallel || parallelSelect.value || null;
    try{
      const pNorm = await fetchAndNormalize(file);
      const parNorm = pFile ? await fetchAndNormalize(pFile) : null;
      primarySelReader.value = file;
      parallelSelReader.value = pFile || '';
      // bounds fix
      if(state.bookIndex >= pNorm.books.length) state.bookIndex = 0;
      const bookObj = pNorm.books[state.bookIndex];
      if(!bookObj){ versesContainer.innerHTML = "<div style='padding:12px'>No data</div>"; currentRef.textContent = ""; return; }
      if(state.chapter >= bookObj.chapters.length) state.chapter = 0;
      currentRef.textContent = `${bookObj.name} ${state.chapter + 1} ${state.parallel ? ' — ' + (pFile ? (pFile.replace("_bible.json","").toUpperCase()) : '') : ''}`;
      // render content
      const chapterArr = bookObj.chapters[state.chapter] || [];
      // if verse specified -> single or range
      if(state.verse){
        // exact key
        const exactIndex = chapterArr.findIndex(v => v.key === state.verse);
        if(exactIndex !== -1){
          renderVerseBlock(exactIndex, pFile ? parNorm : null);
          showReaderNav(true, exactIndex);
          return;
        }
        // range like 7-8
        const m = state.verse.match(/^(\d+)\s*-\s*(\d+)$/);
        if(m){
          const s = Math.max(1, Number(m[1])) - 1;
          const e = Math.max(1, Number(m[2])) - 1;
          const start = Math.max(0, Math.min(s, chapterArr.length-1));
          const end = Math.max(start, Math.min(e, chapterArr.length-1));
          renderCombinedRange(start, end, parNorm);
          showReaderNav(true, start);
          return;
        }
        // numeric single fallback
        if(/^\d+$/.test(state.verse)){
          const idx = Math.max(0, Math.min(Number(state.verse)-1, chapterArr.length-1));
          renderVerseBlock(idx, parNorm);
          showReaderNav(true, idx);
          return;
        }
        versesContainer.innerHTML = "<div style='padding:12px;color:#666'>Verse not found</div>";
        showReaderNav(false);
        return;
      }
      // else full chapter
      renderFullChapter(chapterArr, parNorm);
      showReaderNav(false);
    }catch(e){
      versesContainer.innerHTML = "<div style='padding:12px;color:#666'>Load failed: " + esc(e.message) + "</div>";
    }
  }

  function renderVerseBlock(index, parNorm){
    versesContainer.innerHTML = '';
    const bookParCh = parNorm ? (parNorm.books[state.bookIndex]?.chapters[state.chapter] || []) : null;
    const v = bibleNorm[state.version]?.books[state.bookIndex]?.chapters[state.chapter]?.[index] || null;
    const primText = v ? v.text : '';
    const parText = (bookParCh && bookParCh[index]) ? bookParCh[index].text : '';
    const block = document.createElement('div');
    block.className = 'verse-block active-verse';
    block.innerHTML = `<div class="verse-num">Verse ${v ? v.key : index+1}</div>
      <div class="verse-primary">${esc(primText)}</div>
      ${parText ? `<div class="verse-parallel">${esc(parText)}</div>` : ''}`;
    versesContainer.appendChild(block);
  }

  function renderCombinedRange(start, end, parNorm){
    const arr = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter] || [];
    const prim = arr.slice(start, end+1).map(x=>x.text).join(' ');
    const parCh = parNorm ? (parNorm.books[state.bookIndex]?.chapters[state.chapter] || []) : [];
    const par = parCh.slice(start, end+1).map(x=>x.text).join(' ');
    versesContainer.innerHTML = `<div class="verse-block active-verse">
      <div class="verse-num">Verse ${arr[start].key}${start!==end ? ('-' + arr[end].key) : ''}</div>
      <div class="verse-primary">${esc(prim)}</div>
      ${par ? `<div class="verse-parallel">${esc(par)}</div>` : '' }
    </div>`;
  }

  function renderFullChapter(chapterArr, parNorm){
    versesContainer.innerHTML = '';
    const parCh = parNorm ? (parNorm.books[state.bookIndex]?.chapters[state.chapter] || []) : [];
    for(let i=0; i<chapterArr.length; i++){
      const v = chapterArr[i];
      const prim = v.text;
      const par = parCh[i] ? parCh[i].text : '';
      const block = document.createElement('div');
      block.className = 'verse-block';
      block.innerHTML = `<div class="verse-num">Verse ${v.key}</div>
        <div class="verse-primary">${esc(prim)}</div>
        ${par ? `<div class="verse-parallel">${esc(par)}</div>` : ''}`;
      versesContainer.appendChild(block);
    }
  }

  // reader navigation UI
  let currentVerseIndex = null;
  function showReaderNav(show, idx = null){
    readerNav.style.display = show ? 'flex' : 'none';
    currentVerseIndex = (typeof idx === 'number') ? idx : null;
  }

  // find parallel text helper
  function findParallelText(key){
    const pfile = state.parallel;
    if(!pfile || !bibleNorm[pfile]) return null;
    const pbook = bibleNorm[pfile].books[state.bookIndex];
    if(!pbook) return null;
    const pch = pbook.chapters[state.chapter] || [];
    const found = pch.find(x=>x.key === key);
    return found ? found.text : null;
  }

  // prev/next verse & chapter helpers
  prevVerse.onclick = ()=>{
    if(currentVerseIndex === null) return;
    if(currentVerseIndex > 0){
      state.verse = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter][currentVerseIndex-1].key;
      navigateToRead();
    } else {
      // previous chapter last verse
      if(state.chapter > 0){
        state.chapter--; const ch = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter];
        state.verse = ch[ch.length-1].key;
        navigateToRead();
      }
    }
  };
  nextVerse.onclick = ()=>{
    if(currentVerseIndex === null) return;
    const len = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter].length;
    if(currentVerseIndex < len - 1){
      state.verse = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter][currentVerseIndex+1].key;
      navigateToRead();
    } else {
      if(state.chapter + 1 < bibleNorm[state.version].books[state.bookIndex].chapters.length){
        state.chapter++; state.verse = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter][0].key; navigateToRead();
      }
    }
  };
  prevChapter.onclick = ()=>{
    if(state.chapter > 0){ state.chapter--; state.verse = null; navigateToRead(); }
  };
  nextChapter.onclick = ()=>{
    if(state.chapter + 1 < bibleNorm[state.version].books[state.bookIndex].chapters.length){ state.chapter++; state.verse = null; navigateToRead(); }
  };

  // touch + mouse drag + keys for chapter navigation
  let touchStartX = 0;
  document.addEventListener('touchstart', e => touchStartX = e.changedTouches[0].clientX);
  document.addEventListener('touchend', e => {
    const dx = e.changedTouches[0].clientX - touchStartX;
    if(Math.abs(dx) < 60) return;
    if(dx < 0) { if(state.chapter + 1 < bibleNorm[state.version].books[state.bookIndex].chapters.length){ state.chapter++; state.verse = null; navigateToRead(); } }
    else { if(state.chapter > 0){ state.chapter--; state.verse = null; navigateToRead(); } }
  });

  // mouse drag
  let mouseDown = false, startX=0, currentX=0;
  versesContainer.addEventListener('mousedown', e=> { mouseDown = true; startX = e.clientX; });
  document.addEventListener('mousemove', e=>{ if(!mouseDown) return; currentX = e.clientX; });
  document.addEventListener('mouseup', e=>{ if(!mouseDown) return; mouseDown=false; const dx = (currentX || e.clientX) - startX; if(Math.abs(dx) > 80) { if(dx < 0) { if(state.chapter + 1 < bibleNorm[state.version].books[state.bookIndex].chapters.length){ state.chapter++; state.verse = null; navigateToRead(); } } else { if(state.chapter > 0){ state.chapter--; state.verse = null; navigateToRead(); } } startX = currentX = 0; } });

  // arrow keys for chapters
  document.addEventListener('keydown', e=>{
    if(e.key === 'ArrowRight') { if(state.chapter + 1 < bibleNorm[state.version].books[state.bookIndex].chapters.length){ state.chapter++; state.verse = null; navigateToRead(); } }
    if(e.key === 'ArrowLeft') { if(state.chapter > 0){ state.chapter--; state.verse = null; navigateToRead(); } }
  });

  // TTS implementation (Primary -> Parallel alternating)
  let ttsQueue = [];
  function buildTTSQueue(){
    ttsQueue = [];
    const ch = bibleNorm[state.version].books[state.bookIndex].chapters[state.chapter] || [];
    const pch = state.parallel && bibleNorm[state.parallel] ? (bibleNorm[state.parallel].books[state.bookIndex].chapters[state.chapter] || []) : [];
    if(state.verse){
      const idx = ch.findIndex(v => v.key === state.verse);
      if(idx !== -1){ ttsQueue.push({text: ch[idx].text, idx}); if(pch[idx]) ttsQueue.push({text: pch[idx].text, idx}); return; }
      const m = state.verse.match(/^(\d+)\s*-\s*(\d+)$/);
      if(m){
        const s = Number(m[1]) - 1; const e = Number(m[2]) - 1;
        const start = Math.max(0, Math.min(s, ch.length-1)); const end = Math.max(start, Math.min(e, ch.length-1));
        for(let i=start;i<=end;i++){ ttsQueue.push({text: ch[i].text, idx:i}); if(pch[i]) ttsQueue.push({text: pch[i].text, idx:i}); }
        return;
      }
      if(/^\d+$/.test(state.verse)){
        const idx = Math.max(0, Math.min(Number(state.verse)-1, ch.length-1));
        ttsQueue.push({text: ch[idx].text, idx}); if(pch[idx]) ttsQueue.push({text: pch[idx].text, idx}); return;
      }
      return;
    }
    for(let i=0;i<ch.length;i++){ ttsQueue.push({text: ch[i].text, idx:i}); if(pch[i]) ttsQueue.push({text: pch[i].text, idx:i}); }
  }

  function speakNext(){
    if(ttsQueue.length === 0) return;
    const it = ttsQueue.shift();
    const blocks = document.querySelectorAll('.verse-block');
    blocks.forEach(b=>b.classList.remove('active-verse'));
    if(blocks[it.idx]) { blocks[it.idx].classList.add('active-verse'); blocks[it.idx].scrollIntoView({behavior:'smooth', block:'center'}); }
    const u = new SpeechSynthesisUtterance(String(it.text));
    u.rate = 1.0;
    u.onend = ()=> setTimeout(speakNext, 120);
    u.onerror = ()=> setTimeout(speakNext, 180);
    speechSynthesis.speak(u);
  }

  ttsPlay.onclick = ()=> { speechSynthesis.cancel(); buildTTSQueue(); speakNext(); };
  ttsPause.onclick = ()=> { try{ speechSynthesis.pause(); }catch(e){} };
  ttsResume.onclick = ()=> { try{ speechSynthesis.resume(); }catch(e){} };
  ttsStop.onclick = ()=> { try{ speechSynthesis.cancel(); ttsQueue=[]; }catch(e){} };

  // handle history navigation (back/forward)
  window.addEventListener('popstate', ev=>{
    readUrlToState();
    if(state.view === 'read') navigateToRead(false);
    else navigateToList(false);
  });

  // handlers in reader for version switching
  primarySelReader.onchange = function(){ state.version = this.value; navigateToRead(); primarySelect.value = this.value; };
  parallelSelReader.onchange = function(){ state.parallel = this.value || null; navigateToRead(); parallelSelect.value = this.value || ''; };

  // handlers for top controls to go to read view
  openBtn.onclick = function(){
    state.version = primarySelect.value || state.version || FILES[0];
    state.bookIndex = 0; state.chapter = 0; state.verse = null;
    state.parallel = parallelSelect.value || null;
    navigateToRead();
  };

  // list click handlers will call navigateToRead with state set
  // Jump and Search already set state and call navigateToRead

  // when search results click we already set state and call navigateToRead

  // initial bootstrap: if state.view read then go to reader, else show list
  // preload version data minimally to render list preview
  // prefetch all small? we fetch lazily
  (async function bootstrap(){
    // if primarySelect hasn't any value, set default
    if(!primarySelect.value) primarySelect.value = state.version || FILES[0];
    if(!parallelSelect.value) parallelSelect.value = state.parallel || '';
    try{ await fetchAndNormalize(state.version || primarySelect.value); }catch(e){}
    await renderBooksPreview();
    if(state.view === 'read'){
      await navigateToRead(false);
    } else {
      navigateToList(false);
    }
  })();

  // convenience: allow clicking book/chapter from list to open in reader
  // booksPreview will have buttons already wired in renderBooksPreview

})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bible Reader — Parallel + TTS + Clean UI (Final)</title>

<!-- Beautiful serif for verses -->
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#f7f9fc;
    --card:#ffffff;
    --accent:#0b66c2;
    --text:#1d2d35;
    --border:#e2e8f0;
    --soft:#f4f8ff;
    --highlight:#fff3c4;
    --pulse:#ffda6b;
  }

  *{box-sizing:border-box;margin:0;padding:0;font-family:Inter,system-ui,system-ui,-apple-system,"Segoe UI",Roboto,Arial}

  body{
    background:var(--bg);
    color:var(--text);
    -webkit-font-smoothing:antialiased;
  }

  header{
    padding:14px 20px;
    background:#fff;
    border-bottom:1px solid var(--border);
    position:sticky;top:0;z-index:100;
    display:flex;justify-content:space-between;align-items:center;
  }
  header .brand{font-size:20px;font-weight:700;color:var(--accent)}
  header .meta{font-size:13px;color:#6f7f8b}

  main{max-width:960px;margin:20px auto;padding:0 18px}

  /* Controls Row */
  .controls{
    display:flex;flex-wrap:wrap;gap:12px;
    justify-content:center;
    margin-bottom:16px;
  }
  select,input{
    padding:12px;border-radius:10px;border:1px solid var(--border);
    background:#fff;font-size:14px;min-width:140px;
  }
  button{
    border:0;background:var(--accent);color:#fff;
    padding:10px 16px;border-radius:10px;font-weight:600;
    cursor:pointer;font-size:14px;
  }

  /* TTS Floating Pill Buttons */
  .tts-bar{
    display:flex;gap:12px;justify-content:center;
    margin:10px 0 18px 0;
  }
  .tts-pill{
    background:var(--accent);
    color:white;
    padding:12px 22px;
    border-radius:30px;
    font-size:14px;
    font-weight:600;
    display:flex;align-items:center;gap:8px;
    box-shadow:0 3px 8px rgba(0,0,0,0.12);
    transition:0.18s;
  }
  .tts-pill:active{ transform:translateY(1px); }
  .tts-pill[aria-disabled="true"]{ opacity:0.6; pointer-events:none; }

  /* Jump Menu */
  .jump-container{
    background:white;
    border-radius:12px;
    border:1px solid var(--border);
    margin-bottom:18px;
    overflow:hidden;
  }
  .jump-header{
    padding:14px 16px;
    background:var(--soft);
    cursor:pointer;
    font-weight:700;
    color:var(--accent);
    user-select:none;
  }
  .jump-body{
    display:none;
    padding:14px;
    background:#fff;
  }
  .jump-body select{ min-width:140px; margin-right:8px; padding:10px; }

  /* Reader */
  .reader{
    background:white;
    border-radius:12px;
    border:1px solid var(--border);
    padding:18px;
    margin-bottom:20px;
  }
  .ref{
    font-size:22px;font-weight:700;color:var(--accent);
    margin-bottom:16px;
  }

  .verse-block{
    padding:14px;
    background:#f8fbff;
    border-radius:12px;
    border:1px solid var(--border);
    margin-bottom:14px;
    transition:0.25s;
  }
  .verse-num{
    font-size:13px;font-weight:700;color:#345;margin-bottom:6px;
  }
  .verse-primary{
    font-family:"Noto Serif",serif;font-size:18px;line-height:1.75;
    color:#111;
  }
  .verse-parallel{
    margin-top:10px;padding-left:14px;border-left:3px solid var(--accent);
    font-family:"Noto Serif",serif;font-size:17px;line-height:1.7;color:#2a3c55;
  }

  /* Active Verse Animation */
  .active-verse{
    background:#fff8d1 !important;
    border-color:#ffd56b !important;
    animation:pulseAnim 1.4s infinite ease-in-out;
  }
  @keyframes pulseAnim{
    0%{box-shadow:0 0 0px var(--pulse)}
    50%{box-shadow:0 0 12px var(--pulse)}
    100%{box-shadow:0 0 0px var(--pulse)}
  }

  /* Search Items */
  .search-item{
    padding:12px;border-radius:10px;border:1px solid var(--border);
    background:white;margin-bottom:10px;cursor:pointer;
  }
  .highlight{background:var(--highlight);border-radius:4px;padding:2px}

  /* Notice */
  .notice{
    position:fixed;top:70px;left:20px;right:20px;padding:12px;border-radius:10px;
    background:white;border:1px solid var(--border);text-align:center;display:none;z-index:200;
  }

  @media(max-width:600px){
    .tts-pill{padding:10px 16px;font-size:13px}
    .controls select,input{width:100%}
    .jump-body select{width:100%;margin-bottom:8px}
    .jump-body{display:block}
  }
</style>
</head>

<body>

<header>
  <div class="brand">Bible Reader</div>
  <div class="meta">Parallel • Clean UI • TTS</div>
</header>

<main>

  <!-- CONTROLS -->
  <div class="controls" id="topControls">
    <select id="primarySelect" aria-label="Primary Version"><option value="">PRIMARY VERSION</option></select>
    <select id="parallelSelect" aria-label="Parallel Version"><option value="">PARALLEL VERSION</option></select>
    <button id="openBtn" aria-label="Open default chapter">Open</button>
    <input id="searchBox" placeholder="Search…" aria-label="Search" style="min-width:200px">
    <button id="searchBtn" aria-label="Run search">Search</button>
  </div>

  <!-- TTS PILL BUTTONS -->
  <div class="tts-bar" role="toolbar" aria-label="TTS Controls">
    <button id="ttsPlay" class="tts-pill" aria-label="Play">▶ Play</button>
    <button id="ttsPause" class="tts-pill" aria-label="Pause">⏸ Pause</button>
    <button id="ttsResume" class="tts-pill" aria-label="Resume">⏯ Resume</button>
    <button id="ttsStop" class="tts-pill" aria-label="Stop">⏹ Stop</button>
  </div>

  <!-- JUMP MENU -->
  <div class="jump-container" aria-hidden="false">
    <div class="jump-header" id="jumpToggle">▼ Jump to Book / Chapter / Verse</div>
    <div class="jump-body" id="jumpBody" aria-hidden="true">
      <select id="bookSelect" aria-label="Book"><option value="">Book</option></select>
      <select id="chapterSelect" aria-label="Chapter"><option value="">Chapter</option></select>
      <select id="verseSelect" aria-label="Verse"><option value="">Verse</option></select>
      <button id="jumpGo">Go</button>
    </div>
  </div>

  <!-- READER -->
  <div class="reader">
    <div id="currentRef" class="ref"></div>
    <div id="versesContainer"></div>
  </div>

  <!-- SEARCH RESULTS -->
  <div id="searchInfo" style="margin-bottom:6px;color:#666"></div>
  <div id="searchResults"></div>

</main>

<div id="notice" class="notice" role="status" aria-live="polite"></div>

<script>
/* =============================
   FULL INLINE JS - FINAL
   TTS MODE A: Primary -> Parallel
   No voice selector
   Uses jsDelivr CDN with your repo filenames
============================= */

(() => {
  // CONFIG: CDN base + filenames (exact from your repo)
  const BASE = "https://cdn.jsdelivr.net/gh/udaykumar093986/bibles@main/";
  const FILES = [
    "AMP_bible.json","CSB_bible.json","ESV_bible.json","KJV_bible.json","NIV_bible.json",
    "NKJV_bible.json","NLT_bible.json","afrikaans_bible.json","bengali_bible.json","gujarati_bible.json",
    "hindi_bible.json","hungarian_bible.json","indonesian_bible.json","kannada_bible.json","malayalam_bible.json",
    "marathi_bible.json","nepali_bible.json","odia_bible.json","punjabi_bible.json","sepedi_bible.json",
    "tamil_bible.json","telugu_bible.json","xhosa_bible.json","zulu_bible.json"
  ];

  // DOM
  const primarySelect = document.getElementById("primarySelect");
  const parallelSelect = document.getElementById("parallelSelect");
  const openBtn = document.getElementById("openBtn");
  const searchBox = document.getElementById("searchBox");
  const searchBtn = document.getElementById("searchBtn");
  const ttsPlay = document.getElementById("ttsPlay");
  const ttsPause = document.getElementById("ttsPause");
  const ttsResume = document.getElementById("ttsResume");
  const ttsStop = document.getElementById("ttsStop");
  const jumpToggle = document.getElementById("jumpToggle");
  const jumpBody = document.getElementById("jumpBody");
  const bookSelect = document.getElementById("bookSelect");
  const chapterSelect = document.getElementById("chapterSelect");
  const verseSelect = document.getElementById("verseSelect");
  const jumpGo = document.getElementById("jumpGo");
  const currentRef = document.getElementById("currentRef");
  const versesContainer = document.getElementById("versesContainer");
  const searchResults = document.getElementById("searchResults");
  const searchInfo = document.getElementById("searchInfo");
  const notice = document.getElementById("notice");

  // state & caches
  const versionMap = {};
  const bibleCache = {};   // label -> normalized data
  const searchIndex = {};  // label -> flattened index
  let current = { version: null, parallel: null, book: 0, chapter: 0 };

  // populate versionMap and selects (labels uppercase)
  FILES.forEach(fn => {
    const label = fn.replace("_bible.json","").toUpperCase();
    versionMap[label] = fn;
    primarySelect.appendChild(new Option(label, label));
    parallelSelect.appendChild(new Option(label, label));
  });

  // helper escape
  function esc(s){ return (s===undefined || s===null) ? "" : s.toString().replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

  function showNotice(msg, ms=1600){
    notice.textContent = msg;
    notice.style.display = "block";
    setTimeout(()=> notice.style.display = "none", ms);
  }

  // normalize shapes (support both formats)
  function normalize(json){
    const out = { books: [] };
    if(json.books && Array.isArray(json.books)){
      out.books = json.books.map(b => ({
        name: b.name || b.book || "Unknown",
        chapters: (b.chapters || []).map(c => Array.isArray(c) ? c : Object.values(c || {}))
      }));
      return out;
    }
    // object keyed by book name
    for(const bkName of Object.keys(json || {})){
      const bookObj = json[bkName];
      const chapters = [];
      if(bookObj && Array.isArray(bookObj.chapters)){
        for(const ch of bookObj.chapters) chapters.push(Array.isArray(ch) ? ch : Object.values(ch));
      } else {
        const keys = Object.keys(bookObj || {}).sort((a,b)=>Number(a)-Number(b));
        for(const k of keys){
          const ch = bookObj[k];
          if(Array.isArray(ch)) chapters.push(ch);
          else if(typeof ch === "object") chapters.push(Object.keys(ch).sort((a,b)=>Number(a)-Number(b)).map(i=>ch[i]));
          else chapters.push([String(ch)]);
        }
      }
      out.books.push({ name: bkName, chapters });
    }
    return out;
  }

  // load version json (cached)
  async function loadVersion(label){
    if(!label) throw new Error("No label");
    if(bibleCache[label]) return bibleCache[label];
    const url = BASE + versionMap[label];
    const res = await fetch(url);
    if(!res.ok) throw new Error("Fetch failed: " + res.status);
    const j = await res.json();
    const norm = normalize(j);
    bibleCache[label] = norm;
    buildIndex(label, norm);
    return norm;
  }

  // build flattened search index
  function buildIndex(label, norm){
    const idx = [];
    norm.books.forEach((b, bi) => {
      b.chapters.forEach((ch, ci) => {
        ch.forEach((v, vi) => {
          const text = (v || "").toString();
          idx.push({
            bookIndex: bi, chapterIndex: ci, verseIndex: vi,
            book: b.name, chapter: ci + 1, verse: vi + 1,
            text, low: text.toLowerCase()
          });
        });
      });
    });
    searchIndex[label] = idx;
  }

  // render chapter with parallel mixed block
  function renderChapter(){
    if(!current.version || !bibleCache[current.version]){
      versesContainer.innerHTML = "<div style='padding:12px'>Select a version and open a chapter</div>";
      currentRef.textContent = "";
      return;
    }
    const bookObj = bibleCache[current.version].books[current.book];
    const primaryChap = bookObj.chapters[current.chapter] || [];
    let parallelChap = null;
    if(current.parallel && bibleCache[current.parallel]){
      const pb = bibleCache[current.parallel].books[current.book];
      parallelChap = pb ? (pb.chapters[current.chapter] || []) : null;
    }
    currentRef.textContent = `${bookObj.name} ${current.chapter + 1}` + (current.parallel ? ` — ${current.parallel}` : "");
    let html = "";
    for(let i=0;i<primaryChap.length;i++){
      const prim = esc(primaryChap[i]);
      const par = parallelChap ? esc(parallelChap[i] || "") : "";
      html += `<div class="verse-block" id="v-${i}">
                 <div class="verse-num">Verse ${i+1}</div>
                 <div class="verse-primary">${prim}</div>
                 ${ par ? `<div class="verse-parallel">${par}</div>` : "" }
               </div>`;
    }
    versesContainer.innerHTML = html || "<div style='padding:12px'>No verses found</div>";
    // when chapter renders, populate jump selects (books/chapters/verses)
    populateBooksChaptersVerses();
  }

  // SEARCH
  async function runSearch(){
    const q = (searchBox.value || "").trim().toLowerCase();
    searchResults.innerHTML = ""; searchInfo.textContent = "";
    if(!q) return;
    if(!current.version){
      searchInfo.textContent = "Select primary version first";
      return;
    }
    if(!searchIndex[current.version]) await loadVersion(current.version);
    if(current.parallel && !bibleCache[current.parallel]) await loadVersion(current.parallel);
    const idx = searchIndex[current.version] || [];
    const results = [];
    const max = 200;
    for(let i=0;i<idx.length && results.length < max;i++){
      if(idx[i].low.includes(q)) results.push(idx[i]);
    }
    searchInfo.textContent = `Found ${results.length}${results.length>=max ? " (showing first "+max+")":""}`;
    if(!results.length){ searchResults.innerHTML = "<div style='padding:8px;color:#666'>No results</div>"; return; }
    const safe = q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    const re = new RegExp(safe, "ig");
    const frag = document.createDocumentFragment();
    results.forEach(r => {
      const div = document.createElement("div");
      div.className = "search-item";
      const primarySnippet = esc(r.text).replace(re, m => `<span class="highlight">${m}</span>`);
      let parallelSnippet = "";
      if(current.parallel && bibleCache[current.parallel]){
        const pv = (bibleCache[current.parallel].books[r.bookIndex].chapters[r.chapterIndex][r.verseIndex] || "");
        parallelSnippet = esc(pv).replace(re, m => `<span class="highlight">${m}</span>`);
      }
      div.innerHTML = `<strong>${esc(r.book)} ${r.chapter}:${r.verse}</strong>
                       <div style="margin-top:6px">${primarySnippet}</div>
                       ${ parallelSnippet ? `<div style="margin-top:8px;color:#345">${parallelSnippet}</div>` : "" }
                       <small style="display:block;margin-top:6px;color:#666">Click to open</small>`;
      div.onclick = async () => {
        current.book = r.bookIndex;
        current.chapter = r.chapterIndex;
        await loadVersion(current.version);
        if(current.parallel) await loadVersion(current.parallel);
        renderChapter();
        setTimeout(()=>{
          const el = document.getElementById("v-" + r.verseIndex);
          if(el){
            el.classList.add("active-verse");
            el.scrollIntoView({behavior:"smooth", block:"center"});
            setTimeout(()=> el.classList.remove("active-verse"), 3500);
          }
        }, 200);
      };
      frag.appendChild(div);
    });
    searchResults.appendChild(frag);
  }

  // JUMP menu population helpers
  function populateBooksChaptersVerses(){
    // only populate if current.version loaded
    if(!current.version || !bibleCache[current.version]) return;
    // populate book select if empty
    if(bookSelect.options.length <= 1){
      bookSelect.innerHTML = "<option value=''>Book</option>";
      bibleCache[current.version].books.forEach((b, i) => {
        bookSelect.appendChild(new Option(b.name, i));
      });
    }
    // populate chapters for current.book
    const chapters = bibleCache[current.version].books[current.book].chapters.length;
    chapterSelect.innerHTML = "<option value=''>Chapter</option>";
    for(let i=1;i<=chapters;i++){
      chapterSelect.appendChild(new Option(i, i-1));
    }
    // populate verses for current.chapter
    const versesCount = bibleCache[current.version].books[current.book].chapters[current.chapter].length;
    verseSelect.innerHTML = "<option value=''>Verse</option>";
    for(let v=1; v<=versesCount; v++){
      verseSelect.appendChild(new Option(v, v-1));
    }
    // set selects to current values
    bookSelect.value = current.book;
    chapterSelect.value = current.chapter;
  }

  // OPEN default (first book, first chapter)
  async function openDefault(){
    if(!current.version){ showNotice("Select primary version"); return; }
    current.book = 0; current.chapter = 0;
    await loadVersion(current.version);
    if(current.parallel) await loadVersion(current.parallel);
    renderChapter();
  }

  // JUMP actions
  bookSelect.onchange = function(){
    current.book = Number(this.value || 0);
    current.chapter = 0;
    populateBooksChaptersVerses();
  };
  chapterSelect.onchange = function(){
    current.chapter = Number(this.value || 0);
    populateBooksChaptersVerses();
  };
  jumpGo.onclick = function(){
    renderChapter();
    const vi = verseSelect.value;
    if(vi !== ""){
      setTimeout(()=>{
        const el = document.getElementById("v-" + Number(vi));
        if(el){
          el.classList.add("active-verse");
          el.scrollIntoView({behavior:"smooth", block:"center"});
          setTimeout(()=> el.classList.remove("active-verse"), 3000);
        }
      }, 200);
    }
  };

  // TTS Engine (Primary -> Parallel), queue + auto-scroll + highlight
  let queue = [];
  function buildTTSQueue(){
    queue = [];
    if(!current.version || !bibleCache[current.version]) return;
    const bookObj = bibleCache[current.version].books[current.book];
    const primary = bookObj.chapters[current.chapter] || [];
    let parallel = null;
    if(current.parallel && bibleCache[current.parallel]){
      const pb = bibleCache[current.parallel].books[current.book];
      parallel = pb ? (pb.chapters[current.chapter] || []) : null;
    }
    for(let i=0;i<primary.length;i++){
      const pText = (primary[i] || "").toString().trim();
      if(pText) queue.push({type:"speak", text:pText, index:i});
      if(parallel){
        const parText = (parallel[i] || "").toString().trim();
        if(parText) queue.push({type:"speak", text:parText, index:i});
      }
      queue.push({type:"pause", ms:220});
    }
  }

  function highlightVerse(i){
    document.querySelectorAll(".active-verse").forEach(el => el.classList.remove("active-verse"));
    const el = document.getElementById("v-" + i);
    if(el){
      el.classList.add("active-verse");
      el.scrollIntoView({behavior:"smooth", block:"center"});
    }
  }

  function speakNext(){
    if(queue.length === 0){
      return;
    }
    const item = queue.shift();
    if(item.type === "pause"){
      setTimeout(speakNext, item.ms);
      return;
    }
    if(item.type === "speak"){
      highlightVerse(item.index);
      const utt = new SpeechSynthesisUtterance(item.text);
      // default browser voice; no selector per request
      utt.rate = 1.0;
      utt.onend = () => setTimeout(speakNext, 120);
      utt.onerror = () => setTimeout(speakNext, 200);
      speechSynthesis.speak(utt);
    } else {
      setTimeout(speakNext, 120);
    }
  }

  // TTS handlers
  ttsPlay.onclick = async function(){
    if(!current.version){ showNotice("Open a chapter first"); return; }
    // ensure versions loaded
    try{
      await loadVersion(current.version);
      if(current.parallel) await loadVersion(current.parallel);
    } catch(e){
      showNotice("Failed to load for TTS");
      return;
    }
    speechSynthesis.cancel();
    buildTTSQueue();
    speakNext();
  };
  ttsPause.onclick = function(){ if('speechSynthesis' in window) speechSynthesis.pause(); };
  ttsResume.onclick = function(){ if('speechSynthesis' in window) speechSynthesis.resume(); };
  ttsStop.onclick = function(){ if('speechSynthesis' in window){ speechSynthesis.cancel(); queue = []; } };

  // Jump toggle
  jumpToggle.onclick = function(){
    const visible = jumpBody.style.display === "block";
    jumpBody.style.display = visible ? "none" : "block";
  };

  // UI event wiring
  primarySelect.onchange = async function(){
    const label = this.value;
    if(!label) return;
    current.version = label;
    try{ await loadVersion(label); showNotice(label + " loaded", 800); } catch(e){ showNotice("Load failed"); }
    // reset current book/chapter
    current.book = 0; current.chapter = 0;
    // populate jump lists
    populateBooksChaptersVerses();
  };

  parallelSelect.onchange = async function(){
    const label = this.value || null;
    current.parallel = label;
    if(label){
      try{ await loadVersion(label); showNotice(label + " loaded (parallel)", 800); } catch(e){ /* ignore */ }
    }
  };

  openBtn.onclick = openDefault;

  searchBtn.onclick = runSearch;
  searchBox.onkeydown = function(e){ if(e.key === "Enter") runSearch(); };

  // Expose openResult for search items (used in innerHTML)
  window.openResult = async function(bi, ci, vi){
    current.book = bi; current.chapter = ci;
    if(!current.version) { showNotice("Select primary version"); return; }
    await loadVersion(current.version);
    if(current.parallel) await loadVersion(current.parallel);
    renderChapter();
    setTimeout(()=> {
      const el = document.getElementById("v-" + vi);
      if(el){
        el.classList.add("active-verse");
        el.scrollIntoView({behavior:"smooth", block:"center"});
        setTimeout(()=> el.classList.remove("active-verse"), 3500);
      }
    },200);
  };

  // initial placeholder
  versesContainer.innerHTML = "<div style='padding:12px'>Select PRIMARY version and click Open (optionally choose PARALLEL). Use Search, Jump or TTS to navigate.</div>";

  // small accessibility: keyboard focus visible for pill buttons
  [ttsPlay, ttsPause, ttsResume, ttsStop].forEach(b => {
    b.addEventListener('keyup', (e) => { if(e.key === 'Enter' || e.key === ' ') b.click(); });
  });

  // Preload first version option if you want (optional)
  // If you prefer to auto select a default version uncomment and set below:
  // const defaultVersion = "NKJV"; primarySelect.value = defaultVersion; primarySelect.dispatchEvent(new Event('change'));

})();
</script>

</body>
</html>
